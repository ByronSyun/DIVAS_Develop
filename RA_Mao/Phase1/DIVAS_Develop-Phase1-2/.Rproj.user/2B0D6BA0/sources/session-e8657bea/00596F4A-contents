#' @export
#'
#'
optimal_shrinkage <- function(singvals, beta, loss, percentile, sigma) {
  # similar to MATLAB assertions
  stopifnot(length(beta) == 1)
  stopifnot(beta <= 1)
  stopifnot(beta > 0)
  stopifnot(length(singvals) == length(singvals))
  stopifnot(loss %in% c("fro", "op", "nuc"))

  # Estimate sigma if needed
  #if nargin<5
  # warning('off','MATLAB:quadl:MinStepSize')''
  if (missing(sigma) ||is.null(sigma)) {
    MPmedian <- MedianMarcenkoPastur(beta)
    sigma <- quantile(singvals, probs = percentile) / sqrt(MPmedian)
    cat(sprintf("estimated noise = %0.2f \n", sigma))
  }

  singvals <- optshrink_impl(singvals, beta, loss, sigma)
  noiselvl <- sigma

  return(list(singvals = singvals, noiselvl = noiselvl))
}




optshrink_impl <- function(singvals, beta, loss, sigma) {
  stopifnot(sigma > 0)

  # internal functions for shrinkage as per the loss type
  x <- function(y) {
    sqrt(0.5 * pmax((y^2 - beta - 1) + sqrt(pmax((y^2 - beta - 1)^2 - 4 * beta, 0)), 0)) *
      (y >= 1 + sqrt(beta))
  }

  opt_fro_shrink <- function(y) {
    sqrt(pmax(((y^2 - beta - 1)^2 - 4 * beta), 0)) / y
  }

  opt_op_shrink <- function(y) {
    pmax(x(y), 0)
  }

  opt_nuc_shrink <- function(y) {
    pmax(0, (x(y)^4 - sqrt(beta) * x(y) * y - beta) / ((x(y)^2) * y))
  }

  # Apply the shrinkage based on the loss function
  if (loss == "fro") {
    singvals <- sigma * opt_fro_shrink(singvals / sigma)
  } else if (loss == "nuc") {
    y <- singvals / sigma
    singvals <- sigma * opt_nuc_shrink(y)
    singvals[x(y)^4 - sqrt(beta) * x(y) * y - beta <= 0] <- 0
  } else if (loss == "op") {
    singvals <- sigma * opt_op_shrink(singvals / sigma)
  } else {
    stop("Unknown loss function specified.")
  }

  return(singvals)
}


# function I = MarcenkoPasturIntegral(x, beta)
# if beta <= 0 || beta > 1
# error('beta beyond')
# end
# lobnd = (1 - sqrt(beta))^2;
# hibnd = (1 + sqrt(beta))^2;
# if (x < lobnd) || (x > hibnd)
# error('x beyond')
# end
# dens = @(t) sqrt((hibnd-t).*(t-lobnd))./(2*pi*beta.*t);
# I = integral(dens,lobnd,x);
# fprintf('x=%.3f,beta=%.3f,I=%.3f\n',x,beta,I);
# end


MedianMarcenkoPastur <- function(beta) {
  MarPas <- function(x) 1 - incMarPas(x, beta, 0)
  lobnd <- (1 - sqrt(beta))^2
  hibnd <- (1 + sqrt(beta))^2
  change <- TRUE

  while (change && (hibnd - lobnd > 0.001)) {
    change <- FALSE
    x <- seq(lobnd, hibnd, length.out = 5)
    y <- sapply(x, MarPas)

    if (any(y < 0.5)) {
      lobnd <- max(x[y < 0.5])
      change <- TRUE
    }
    if (any(y > 0.5)) {
      hibnd <- min(x[y > 0.5])
      change <- TRUE
    }
  }

  med <- (hibnd + lobnd) / 2
  return(med)
}






incMarPas <- function(x0, beta, gamma) {
  if (beta > 1) stop("beta beyond")

  topSpec <- (1 + sqrt(beta))^2
  botSpec <- (1 - sqrt(beta))^2
  MarPas <- function(x) ifelse((topSpec - x) * (x - botSpec) > 0,
                               sqrt((topSpec - x) * (x - botSpec)) / (beta * x) / (2 * pi),
                               0)

  if (gamma != 0) {
    fun <- function(x) (x^gamma * MarPas(x))
  } else {
    fun <- MarPas
  }

  I <- integrate(fun, x0, topSpec)$value
  return(I)
}





####################################test######################################
# # from Matlab rng42
# library(R.matlab)
# data <- readMat('optimal_shrinkage_random_matrix.mat')
# X <- data$X
#
# svd_result <- svd(X)
# singvals <- svd_result$d
# beta <-  ncol(X)/nrow(X)
# percentile <- 0.9
# sigma <- 0.5
#
# # Apply op shrinkage
# result <- optimal_shrinkage(singvals, beta, loss = "op", percentile = percentile, sigma = sigma)
#
# cat("Original Singular Values:\n")
# print(singvals)
# cat("Shrunk Singular Values:\n")
# print(result$singvals)
# cat("Estimated Noise Level:\n")
# print(result$noiselvl)

