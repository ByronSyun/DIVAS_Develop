#' Matrix Signal Extraction
#'
#' Performs signal extraction from a data matrix and estimates the signal rank,
#' signal row space, perturbation angles, and noise matrix.
#'
#' @param X The data matrix.
#' @param matName A string representing the matrix name.
#' @param nsim Number of bootstrap samples.
#' @param colCent Logical, whether to center columns.
#' @param rowCent Logical, whether to center rows.
#' @param cull Value to control culling during signal extraction.
#' @param percentile Percentile value for estimating the noise level.
#' @param noiselvl Optional noise level.
#'
#' @return A list containing the adjusted signal row space, perturbation angles,
#' signal rank, noise matrix, and other intermediate results.
#'
MatSignalExtractJP <- function(X, matName, nsim, colCent, rowCent, cull, percentile, noiselvl = NULL) {
  # Matrix signal extraction
  # Estimate signal rank, signal row space, corresponding perturbation
  # angle, and noise matrix. Adjust signals based on random direction angle.
  #
  # Inputs:
  #   X - d x n data matrix
  #   matName - string of matrix name
  #   nsim - number of bootstrap samples
  #
  # Outputs:
  #   VBar - adjusted signal row spacemi
  #   phiBar - adjusted perturbation angle
  #   rBar - adjusted signal rank
  #   EHat - estimated noise matrix
  if (!is.numeric(X)) {
    stop("The input matrix X is not numeric.")
  }
  if (any(is.na(X))) {
    stop("The input matrix X contains NA values.")
  }

  d <- nrow(X)
  n <- ncol(X)
  if (is.null(d) || is.null(n)) {
    stop("The input matrix X has invalid dimensions.")
  }

  mindn <- min(d, n)

  #Perform SVD on the data matrix X
  # svdResult <- svd(X)
  # UFull <- svdResult$u
  # singVals <- svdResult$d
  # VFull <- svdResult$v

  #need convert list
  svdResult <- La.svd(X)
  UFull <- svdResult$u
  singVals <- svdResult$d
  singVals <- matrix(singVals, nrow = length(singVals), ncol = 1)
  #singVals <- diag(as.vector(singVals))
  VFull <- t(svdResult$vt)

  # cat('size of UFull')
  # print(dim(UFull))
  # cat('size of singVals')
  # print(dim(singVals))
  # cat('size of VFull')
  # print(dim(VFull))
  #
  beta <- min(n/d, d/n)
  if (is.null(cull)) {
    cull <- 0.5
  }


  # Check if `noiselvl` is provided
  if (is.null(noiselvl)) {
    # If `noiselvl` is not provided, estimate it using optimal shrinkage
    result <- optimal_shrinkage(singVals, beta, 'op', percentile)
    singValsHat <- result$singvals
    noiselvl <- result$noiselvl
  } else {
    if (noiselvl == 'ks') {
      # If `noiselvl` is set to 'ks', use the ksOpt function to determine the noise level
      noiselvl <- ksOpt(singVals, beta)
    }
    singValsHat <- optimal_shrinkage(singVals, beta, 'op', noiselvl)$singvals
  }

  rHat <- sum(singValsHat > 0)
  cat(sprintf('Initial signal rank for %s is %d.\n', matName, rHat))

  recovBound <- noiselvl * (1 + sqrt(beta))

  svdHat <- RSpectra::svds(X, rHat)
  UHat <- svdHat$u
  VHat <- svdHat$v
  singValsTilde <- singValsHat[1:rHat]
  AHat <- UHat %*% diag(singValsTilde) %*% t(VHat)
  EHat <- X - AHat

  EHatGood <- UFull[, (rHat+1):mindn] %*% diag(singVals[(rHat+1):mindn]) %*% t(VFull[, (rHat+1):mindn])
  XRemaining <- X - EHatGood

  # Imputation of missing energy
  imputedSingVals <- numeric(rHat)
  for (iter in 1:rHat) {
    perc <- runif(1)
    marpas <- PercentileMarcenkoPastur(beta, perc)
    imputedSingVals[iter] <- sqrt(marpas)
  }

  EHatImpute <- EHatGood + UHat %*% diag(imputedSingVals * noiselvl) %*% t(VHat)

  randAngleCache <- randDirAngleMJ(n, rHat, 1000)
  randAngleCacheLoad <- randDirAngleMJ(d, rHat, 1000)
  randAngle <- quantile(randAngleCache, 0.05)
  randAngleLoad <- quantile(randAngleCacheLoad, 0.05)

  rSteps <- rHat

  # Bootstrap estimation and signal rank adjustment by removing PCs with perturbation angle larger
  # than half the value of random direction angle
  PCAnglesCacheFullBoot <- matrix(90, nsim, rHat)
  PCAnglesCacheFullBootLoad <- matrix(90, nsim, rHat)

  cat('Progress Through Bootstrapped Matrices:\n')
  cat(paste0('\n', strrep('.', nsim), '\n\n'))

  for (s in 1:nsim) {
    randV <- matrix(rnorm(n * rHat), n, rHat)
    if (colCent) {
      randV <- randV - matrix(colMeans(randV), n, rHat, byrow = TRUE)
    }
    randV <- qr.Q(qr(randV))

    randU <- matrix(rnorm(d * rHat), d, rHat)

    #print(dim(randV))
    if (rowCent) {
      randU <- randU - matrix(colMeans(randU), d, rHat, byrow = TRUE)
    }
    randU <- qr.Q(qr(randU))
    randX <- randU %*% diag(singValsTilde) %*% t(randV) + EHatImpute
    svdRand <- svds(randX, rHat)
    randUHat <- svdRand$u
    randVHat <- svdRand$v
    # for (j in 1:rHat) {
    #   PCAnglesCacheFullBoot[s, j] <- acosd(min(svd(t(randV) %*% randVHat[, 1:j])))
    #   PCAnglesCacheFullBootLoad[s, j] <- acosd(min(svd(t(randU) %*% randUHat[, 1:j])))
    # }
    # Correcting the angle calculation
    for (j in 1:rHat) {
      svd_randV <- svd(t(randV) %*% randVHat[, 1:j])
      PCAnglesCacheFullBoot[s, j] <- acosd(min(svd_randV$d))  # Extract singular values from svd_randV$d

      svd_randU <- svd(t(randU) %*% randUHat[, 1:j])
      PCAnglesCacheFullBootLoad[s, j] <- acosd(min(svd_randU$d))  # Extract singular values from svd_randU$d
    }

    cat('\b|\n')
  }
  # cat('size of randV2')
  # print(dim(randV))
  # cat('size of PCAnglesCacheFullBootLoad')
  # print(dim(PCAnglesCacheFullBootLoad))
  # print(PCAnglesCacheFullBoot[12,12])
  # print(PCAnglesCacheFullBootLoad[12,12])
  #
  # cat('randAngle dimension and randAngle\n')
  # print(dim(randAngle))
  # print(randAngle)
  # print(as.numeric(randAngle))
  # print(dim(as.numeric(randAngle)))

  randAngle <- as.numeric(randAngle)
  # randAngle <- matrix(randAngle, nrow = 1, ncol = 1)
  # cat('randAngle dimension and randAngle\n')
  # print(dim(randAngle))
  # print(randAngle)
  #
  cull <- as.numeric(cull)
  cull <- matrix(cull, nrow = 1, ncol = 1)
  # cat('cull dimension and cull\n')
  # print(dim(cull))

  # cat('randAngle * culll\n')
  # print(randAngle * cull)
  #
  # cat('cull\n')
  # print(cull)
  #
  # cat('quantile(PCAnglesCacheFullBoot, 0.95, 1)\n')

  rBar_quantiles <- apply(PCAnglesCacheFullBoot, 2, quantile, probs = 0.95)
  # print(dim(rBar_quantiles))
  rBarLoad_quantiles <- apply(PCAnglesCacheFullBootLoad, 2, quantile, probs = 0.95)
  rBar <- sum(rBar_quantiles < as.numeric(randAngle * cull))
  #rBar <-3
  rBarLoad <- sum(rBarLoad_quantiles < as.numeric(randAngleLoad * cull))

  #######
  # cat('rBar')
  # print(rBar)
  # cat('rBarLoad is ',rBarLoad, '\n')

  cat(sprintf('Culled Rank is %d.\n', rBar))

  # validPC <- quantile(PCAnglesCacheFullBoot, 0.95, 1) < randAngle * cull
  quantiles_validPC <- apply(PCAnglesCacheFullBoot, 2, quantile, probs = 0.95)
  validPC <- quantiles_validPC < as.numeric(randAngle * cull)

  # cat('quantiles_validPC is ',quantiles_validPC, '\n')
  # cat('quantiles_validPC dim is ',dim(quantiles_validPC), '\n')
  # cat('randAngle * cull dim is ',dim(randAngle * cull), '\n')
  #
  #validPC <- quantiles_validPC < randAngle * cull
  #cat('validPC is ',validPC, '\n')

  minInd <- which.min(quantile(PCAnglesCacheFullBoot, 0.95, 1))
  minInd <- as.numeric(minInd)
  # cat("minInd\n")
  # print(as.numeric(minInd))
  #

  validPC[minInd] <- TRUE
  rBar <- sum(validPC)
  phiBar <- quantile(PCAnglesCacheFullBoot[, rBar], 0.95)
  psiBar <- quantile(PCAnglesCacheFullBootLoad[, rBar], 0.95)

  VVHatCacheBar <- vector("list", nsim)
  UUHatCacheBar <- vector("list", nsim)
  singValsTildeBar <- singValsTilde[1:rBar]
  for (s in 1:nsim) {
    randV <- matrix(rnorm(n * rBar), n, rBar)
    if (colCent) {
      randV <- randV - matrix(colMeans(randV), n, rBar, byrow = TRUE)
    }
    randV <- qr.Q(qr(randV))
    randU <- matrix(rnorm(d * rBar), d, rBar)
    if (rowCent) {
      randU <- randU - matrix(colMeans(randU), d, rBar, byrow = TRUE)
    }
    randU <- qr.Q(qr(randU))
    ##########
    # cat('size of randU')
    # print(dim(randU))
    # cat('size of diag(singValsTildeBar')
    # print(dim(diag(singValsTildeBar)))
    # cat('size of randV')
    # print(dim(t(randV)))
    # cat('size of Ehat')
    # print(dim(EHat))
    ###########
    randX <- randU %*% diag(singValsTildeBar) %*% t(randV) + EHat
    svdRand <- svds(randX, rBar)
    randUHat <- svdRand$u
    randVHat <- svdRand$v
    VVHatCacheBar[[s]] <- t(randV) %*% randVHat
    UUHatCacheBar[[s]] <- t(randU) %*% randUHat
  }

  # Final Outputs
  VBar <- VHat[, validPC]
  UBar <- UHat[, validPC]

  cat(sprintf('Perturbation Angle for %s is %.1f.\n', matName, phiBar))

  return(list(VBar = VBar, UBar = UBar, phiBar = phiBar, psiBar = psiBar, rBar = rBar,
              EHat = EHat, singVals = singVals, singValsHat = singValsHat, rSteps = rSteps,
              VVHatCacheBar = VVHatCacheBar, UUHatCacheBar = UUHatCacheBar))
}



#
# ####################################test######################################
# # from Matlab rng42
# library(R.matlab)
# data <- readMat('/Users/byronsun/Desktop/RA_Mao/R code DIVAS/MatSignalExtract_matrix2.mat')
# X <- data$X
#
# # cat("First element:", X[1, 1], "\n")
# # cat("Element at (20, 20):", X[20, 20], "\n")
# # svdResult <- La.svd(X)
# # UFull <- svdResult$u
# # singVals <- svdResult$d
# # singVals <- matrix(singVals, nrow = length(singVals), ncol = 1)
# # singVals <- diag(as.vector(singVals))
# # VFull <- t(svdResult$vt)
#
# #
# # cat("size of UFull:\n")
# # print(dim(UFull))
# # cat("size of VFull:\n")
# # print(dim(VFull))
# # cat("First element VFull:", VFull[1, 1], "\n")
# # cat("Element at (20, 20) VFull:", VFull[200, 199], "\n")
# #
# #
#
#
# #cat("First 5 rows of X:\n")
# #print(head(X,1))
#
# matName = 'datablock1';
# nsim = 400;
# colCent = 0;
# rowCent = 0;
# cull = 0.5;
# percentile = 0.3825;
#
#
# result <- MatSignalExtractJP(X, matName, nsim, colCent, rowCent, cull, percentile)
#
# cat("Results from MatSignalExtractJP in R:\n")
# cat("Adjusted signal rank (rBar):", result$rBar, "\n")
# cat("Perturbation angle (phiBar):", result$phiBar, "\n")
# cat("Loadings perturbation angle (psiBar):", result$psiBar, "\n")
# cat("Singular values before shrinkage:\n")
# print(t(result$singVals))
# cat("Singular values after shrinkage:\n")
# print(t(result$singValsHat))
#
# zero_count <- sum(t(result$singValsHat) == 0)
# cat("Number of zeros in the matrix:", zero_count, "\n")
# cat("dim of singValsHat:", dim(result$singValsHat), "\n")
